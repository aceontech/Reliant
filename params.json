{"name":"Reliant","tagline":"dependency injection for iOS and OSX","body":"Reliant\r\n=======\r\n\r\n[![Reliant build status](https://travis-ci.org/appfoundry/Reliant.svg?branch=master)](https://travis-ci.org/appfoundry/reliant)   [![Cocoapods Version](https://cocoapod-badges.herokuapp.com/v/Reliant/badge.png)](http://cocoadocs.org/docsets/Reliant/2.0.1/)\r\n\r\nReliant is a Dependency Injection ([DI](http://martinfowler.com/articles/injection.html \"Martin Fowler never lies\"))\r\nframework for Objective-C, both for OS X and iOS. Its goal is to make its use as simple\r\nas possible, while not limiting possibilities. It aims to have as little impact as\r\npossible on your project code. It also aims to be loyal to Objective-C's [dynamic](http://stackoverflow.com/questions/125367/dynamic-type-languages-versus-static-type-languages)\r\nnature.\r\n\r\n\r\nGetting started\r\n---------------\r\n\r\nIn this section we will get you started with Reliant as quick as possible, if you want to know more\r\n(or in other words, the TL;DR version) we suggest you take a look at our [wiki pages](https://github.com/appfoundry/Reliant/wiki)\r\n\r\n### Installation\r\n\r\nThe easiest way to install Reliant is via CocoaPods\r\n\r\nAdd the following line to your Podfile:\r\n\r\n`pod 'Reliant'`\r\n\r\nThen run `pod install` or `pod update`\r\n\r\n> for more information about CocoaPods, go to http://cocoapods.org\r\n\r\n### Quick-start tutorial\r\n\r\nWe suggest that you first take a look at our [quick-start 'Hello World' tutorial](https://github.com/appfoundry/Reliant/tree/master/Examples/HelloReliant) and sample app, found under the [Examples](https://github.com/appfoundry/Reliant/tree/master/Examples) folder in the Reliant repository.\r\n\r\n\r\nUsing Reliant\r\n-------------\r\n\r\nThe following documentation is based on our more elaborate [sample app](https://github.com/appfoundry/Reliant/tree/master/Examples/ReliantExample), which can also be found under the [Examples](https://github.com/appfoundry/Reliant/tree/master/Examples) folder in the Reliant repository.\r\n\r\n#### Configuration\r\n\r\nYou first need a context in which Reliant will look for your specific objects. The default way to configure such a\r\ncontext is through a configuration class. The example contains some of these. The application wide context is configured\r\nwith the `AppConfiguration` class.\r\n\r\n```objective-c\r\n//Header file omitted\r\n\r\n@implementation AppConfiguration\r\n\r\n- (id<StringProvider>)createSingletonStringProvider {\r\n    return [[DefaultStringProvider alloc] init];\r\n}\r\n\r\n@end\r\n```\r\n\r\nIn this very simple example we have the concept of a `StringProvider` which will generate some strings shown by various\r\nviews in our application. We configure Reliant to create a \"singleton\" instance of this string provider. The reason why\r\nyou would use dependency injection is that you can avoid hard dependencies to implementations. That's why we have\r\na `StringProvider` protocol. The configuration will create an actual implementation instance, but that instance is hidden\r\nfrom the actual dependent application code. In this case we use the `DefaultStringProvider`.\r\n\r\n#### Bootstrapping a context\r\n\r\nBootstrapping a context is very simple. Since we have a configuration for a context which is meant to be used\r\nthroughout the entire application, we will bootstrap this context in the application delegate.\r\n\r\n```objective-c\r\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\r\n    [self ocsBootstrapAndBindObjectContextWithConfiguratorFromClass:[AppConfiguration class]];\r\n}\r\n```\r\n\r\nThis single line of code is the easiest way to bootstrap a context. It wil start the context with the specified\r\nconfiguration class, and then bind that context to `self` which in this case means your application delegate.\r\n\r\n#### Injection\r\n\r\nReliant injects all your objects specified in the configuration. Injection can be done in two ways:\r\n- Initializer injection\r\n- Property injection\r\n\r\nFor simplicity's sake we will use property injection in these examples.\r\n\r\n> We actually prefer initializer injection over property injection, but we will get into that in our [wiki pages](https://github.com/appfoundry/Reliant/wiki).\r\n\r\nLet's say that our `DefaultStringProvider` implementation needs a `StringGenerator` to generate some strings.\r\nWe could do this by simply adding a property named `stringGenerator` on our `DefaultStringProvider`.\r\n\r\n```objective-c\r\n@interface DefaultStringProvider : NSObject<StringProvider>\r\n\r\n@property (nonatomic, strong) id<StringGenerator> stringGenerator;\r\n\r\n@end\r\n```\r\n\r\nNow we just need to add another configuration method to our `AppConfiguration` class.\r\n\r\n```objective-c\r\n//Inside the implementation of our AppConfiguration\r\n\r\n- (id<StringGenerator>)createSingletonStringGenerator {\r\n    return [[DefaultStringGenerator alloc] init];\r\n}\r\n```\r\n\r\nWith that, when you start your application, both the `DefaultStringProvider` and `DefaultStringGenerator` are being\r\ncreated for the AppDelegate's context. Remember when we said they were created as \"singletons\"? Well, they are not real\r\nsingletons, but they are in the `AppDelegate` context. When you ask the context for this object, it will always return\r\nthe same instance, guaranteed.\r\n\r\n> For those of you who prefer to put the property in an anonymous class extension, as we do, that would work as well.\r\n\r\nAfter the creation of an object, it will be injected with other objects known by the context it is created for. So in this\r\ncase the `DefaultStringGenerator` is injected in the `DefaultStringProvider` through its `stringGenerator` property.\r\n\r\nYou easily succeeded in loosly coupling the `StringGenerator` to your `DefaultStringProvider` class.\r\n\r\n#### Manual injection\r\n\r\nIt might not always be possible to configure your objects through Reliant. For instance, a view controller might get created\r\nby a storyboard or by your applications code somewhere. In these cases Reliant will not be able to inject your object\r\nautomatically. However, injecting an object is a one-liner again:\r\n\r\n```objective-c\r\n[self ocsInject];\r\n```\r\n\r\nThis will locate a context based on `self`, and then inject `self`with objects known to the found context.\r\n\r\n#### Naming your objects\r\n\r\nReliant figures out which objects to inject by their given name. In this case, the names of our object are `stringProvider`\r\nand `stringGenerator`. That is why we named the property in `DefaultStringProvider` as such. The names of the objects are\r\nspecified by your configurator. In this case Reliant derives the name from the method names. All text which comes after the\r\n`createSingleton` is seen as a name. The tentative reader might argue that the names should be *StringGenerator* and\r\n*StringProvider* (with starting capital), in fact that is true. However, Reliant has created aliases for these objects\r\nin their camelcase form.\r\n\r\nFurther reading\r\n---------------\r\n\r\nDo not forget to check our [wiki pages](https://github.com/appfoundry/Reliant/wiki) for more details on what is discussed above.\r\nOur API documentation is available via [cocoadocs.org](http://cocoadocs.org/docsets/Reliant/2.0.1/)\r\n\r\nContact\r\n-------\r\nIf not via GitHub, find us on twitter: @AppFoundryBE or @mikeseghers\r\n\r\nLicence\r\n-------\r\n\r\nReliant is released under [MIT licence](http://opensource.org/licenses/MIT)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}